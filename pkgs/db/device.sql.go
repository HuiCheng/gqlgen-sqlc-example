// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: device.sql

package db

import (
	"context"
	"database/sql"
	"strings"

	"idea2/graph/model"
)

const createDevice = `-- name: CreateDevice :one
INSERT INTO
  device (title, address, connect_type, auth_id, note)
VALUES
  (?, ?, ?, ?, ?) RETURNING id, title, address, connect_type, auth_id, note, created_at, updated_at
`

type CreateDeviceParams struct {
	Title       string
	Address     string
	ConnectType string
	AuthID      sql.NullInt64
	Note        string
}

func (q *Queries) CreateDevice(ctx context.Context, arg *CreateDeviceParams) (*Device, error) {
	row := q.db.QueryRowContext(ctx, createDevice,
		arg.Title,
		arg.Address,
		arg.ConnectType,
		arg.AuthID,
		arg.Note,
	)
	var i Device
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Address,
		&i.ConnectType,
		&i.AuthID,
		&i.Note,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listDevices = `-- name: ListDevices :many
SELECT
  device.id, device.title, device.address, device.connect_type, device.auth_id, device.note, device.created_at, device.updated_at,
  device_auth.id, device_auth.title, device_auth.type, device_auth.username, device_auth.password, device_auth.private_key, device_auth.created_at, device_auth.updated_at
FROM
  device
  JOIN device_auth ON device.auth_id = device_auth.id
WHERE
  (IIF(?1, TRUE, NULL))
  OR (
    (
      IIF(?2, device.id IN (/*SLICE:IDs*/?), NULL)
    )
    OR (
      IIF(
        ?4,
        device.auth_id IN (/*SLICE:AuthIDs*/?),
        NULL
      )
    )
  )
LIMIT
  ?7
OFFSET
  ?6
`

type ListDevicesParams struct {
	ByAll     interface{}
	ByIDs     interface{}
	IDs       []int64
	ByAuthIDs interface{}
	AuthIDs   []sql.NullInt64
	PageNum   int64
	PageSize  int64
}

type ListDevicesRow struct {
	ID          int64
	Title       string
	Address     string
	ConnectType string
	AuthID      sql.NullInt64
	Note        string
	CreatedAt   model.Timestamp
	UpdatedAt   *model.Timestamp
	DeviceAuth  DeviceAuth
}

func (q *Queries) ListDevices(ctx context.Context, arg *ListDevicesParams) ([]*ListDevicesRow, error) {
	query := listDevices
	var queryParams []interface{}
	queryParams = append(queryParams, arg.ByAll)
	queryParams = append(queryParams, arg.ByIDs)
	if len(arg.IDs) > 0 {
		for _, v := range arg.IDs {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:IDs*/?", strings.Repeat(",?", len(arg.IDs))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:IDs*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.ByAuthIDs)
	if len(arg.AuthIDs) > 0 {
		for _, v := range arg.AuthIDs {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:AuthIDs*/?", strings.Repeat(",?", len(arg.AuthIDs))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:AuthIDs*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.PageNum)
	queryParams = append(queryParams, arg.PageSize)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListDevicesRow
	for rows.Next() {
		var i ListDevicesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Address,
			&i.ConnectType,
			&i.AuthID,
			&i.Note,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeviceAuth.ID,
			&i.DeviceAuth.Title,
			&i.DeviceAuth.Type,
			&i.DeviceAuth.Username,
			&i.DeviceAuth.Password,
			&i.DeviceAuth.PrivateKey,
			&i.DeviceAuth.CreatedAt,
			&i.DeviceAuth.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDevice = `-- name: UpdateDevice :exec
UPDATE device
SET
  title = ?,
  address = ?,
  connect_type = ?
WHERE
  id = ?
`

type UpdateDeviceParams struct {
	Title       string
	Address     string
	ConnectType string
	ID          int64
}

func (q *Queries) UpdateDevice(ctx context.Context, arg *UpdateDeviceParams) error {
	_, err := q.db.ExecContext(ctx, updateDevice,
		arg.Title,
		arg.Address,
		arg.ConnectType,
		arg.ID,
	)
	return err
}
